/*******************************************************************************
 * Copyright (c) 2003-2022 Regents of the University of California and Broad Institute. All rights reserved.
 *******************************************************************************/
package org.genepattern.server.config;

import static org.genepattern.drm.JobRunner.PROP_DOCKER_IMAGE;
import static org.genepattern.drm.JobRunner.PROP_DOCKER_IMAGE_DEFAULT;
import static org.genepattern.drm.JobRunner.PROP_DOCKER_IMAGE_LOOKUP;
import static org.genepattern.drm.JobRunner.PROP_JOB_COMMAND_PREFIX;

import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;

import org.apache.log4j.Logger;
import org.genepattern.drm.JobRunner;
import org.genepattern.drm.Memory;
import org.genepattern.server.auth.IGroupMembershipPlugin;
import org.genepattern.server.executor.CommandExecutorMapper;
import org.genepattern.server.executor.CommandProperties;
import org.genepattern.server.repository.RepositoryInfo;
import org.genepattern.util.LSID;
import org.genepattern.webservice.JobInfo;

import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;

public class GpConfig {
    private static Logger log = Logger.getLogger(GpConfig.class);
   
    /**
     * Set the 'genepattern.version' in the 'WEB-INF/build.properties' file, e.g.
     * <pre>
     * genepattern.version=3.9.3
     * </pre>
     */
    public static final String PROP_GENEPATTERN_VERSION="genepattern.version";
    
    /**
     * For backwards compatibility with patches which use the <GenePatternVersion> command line substitution.
     * Fix for GP-5805
     */
    public static final String PROP_GENEPATTERN_VERSION_LEGACY="GenePatternVersion";

    /**
     * Set the 'version.label' in the 'WEB-INF/build.properties' file, e.g.
     * <pre>
     * version.label=
     * </pre> 
     */
    public static final String PROP_VERSION_LABEL="version.label";

    /**
     * Set the 'version.revision.id' in the 'WEB-INF/build.properties' file, e.g.
     * <pre>
     * version.revision.id=89
     * </pre>
     */
    public static final String PROP_VERSION_REVISION_ID="version.revision.id";

    /**
     * Set the 'version.build.date' in the 'WEB-INF/build.properties' file, e.g.
     * <pre>
     * version.build.date=2015-06-12 18:40
     * </pre>
     */
    public static final String PROP_VERSION_BUILD_DATE="version.build.date";
    
    /**
     * Set the file system path for GenePattern data files.
     */
    public static final String PROP_GENEPATTERN_HOME="GENEPATTERN_HOME";
    
    /**
     * Set the 'lsid.authority' component for LSIDs created on the server. The initial value
     * is generated by the installer and saved to the genepattern.properties file.
     * The LSID template: <pre>
         lsid=urn:lsid:{lsid.authority}:{namespace}:{identifier}:{version}
     </pre>
     * The 'lsid.authority' template: <pre>
         lsid.authority={port}.{username}.{hostname}[.{ip-address}]

       Example 'lsid.authority' values
       --------------------------------------------------------------------------------
       broad.mit.edu                                - Broad Institute module repository
       broadinstitute.org                           - Broad Institute module repository
       8080.genepatt.genepattern.broadinstitute.org - Created on Broad Server
       8080.gpbroad.broadinstitute.org              - Created on Broad Internal Server
       8082.gpserver.gw66.iu.xsede.org              - Created on GP@IU server
       8080.genepattern.psc.edu                     - Created on GP@PSC server

       8080.my_username.MY-HOSTNAME.203.0.113.17    - Created on Mac OS X server
       broad-cancer-genomics                        - default value in early versions of GP
     </pre>
     *
     */
    public static final String PROP_LSID_AUTHORITY="lsid.authority";
    
    /** default value in early versions of GP is 'broad-cancer-genomics'. */
    public static final String DEFAULT_LSID_AUTHORITY="broad-cancer-genomics";

    /**
     * The version of the database for saving GP session data, default value is 'HSQL'. Other supported
     * options include 'ORACLE' and 'MYSQL'.
     */
    public static final String PROP_DATABASE_VENDOR="database.vendor";

    /**
     * When true, display the 'Estimated Queue Time' details for the Congestion Indicator.
     */
    public static final String PROP_SHOW_ESTIMATED_QUEUETIME="gp.showEstimatedQueuetime";

    /**
     * The location for user data directories.
     */
    public static final String PROP_USER_ROOT_DIR="user.root.dir";
    
    /**
     * The directory to write temporary files to
     */
    public static final String PROP_GP_TMPDIR="gp.tmpdir";

    /**
     * The directory to write files uploaded from SOAP
     */
    public static final String PROP_SOAP_ATT_DIR="soap.attachment.dir";
    
    /**
     * The location for job results files. 
     * Each job runs in a new working directory, by default it is created in the 'jobs' folder,
     *     mkdir <jobs>/<jobId>, e.g.
     *     mkdir /Applications/GenePatternServer/jobResults/1
     */
    public static final String PROP_JOBS="jobs";
    
    /**
     * The location for installed patches (aka plugins).
     */
    public static final String PROP_PLUGIN_DIR="patches";
    
    /**
     * The location for installed tasks (aka modules and pipelines)
     */
    public static final String PROP_TASKLIB_DIR="tasklib";
    
    /**
     * Configure the 'Contact Us' link. Example config_custom.yaml entry:
     *   contact.link: "JavaScript:window.open('https://groups.google.com/forum/#!forum/genepattern-help', 'genepattern-help');"
     *   # (legacy) contactUs.jsf page
     *   # contact.link: "/gp/pages/contactUs.jsf"
     */
    public static final String PROP_CONTACT_LINK="contact.link";

    /**
     * The default 'contact.link' baked into the GP server opens the GenePattern Help forum in a new window.
     */
    public static final String DEFAULT_CONTACT_LINK="JavaScript:window.open('https://groups.google.com/forum/#!forum/genepattern-help', 'genepattern-help');";

    /**
     * Set the 'googleAnalytics.enabled' flag to true to enable Google Analytics for the GP server.
     * When 'true' the ./pages/gpTracking.xhtml file is loaded into the header page for the GP server.
     * You must also set the 'googleAnalytics.trackingId' property in the config yaml file.
     * 
     * For full customization, edit to the gpTracking.xhtml to include whatever code snippet suggested
     * by Google Analytics.
     * 
     */
    public static final String PROP_GA_ENABLED="googleAnalytics.enabled";

    /**
     * Set the 'googleAnalytics.trackingId' for the server.
     * @see GpConfig#PROP_GA_ENABLED
     */
    public static final String PROP_GA_TRACKING_ID="googleAnalytics.trackingId";
    
    /**
     * The 'gp.tools.dir' is a directory path to the location for 3rd-party and other helper tools which are 
     * included as part of the genepattern installation.
     * Default location: <webappDir>/WEB-INF/tools 
     */
    public static final String PROP_GP_TOOLS_DIR="gp.tools.dir";
    
    /**
     * Set 'wrapper-scripts' to a directory path to the built in wrapper scripts.
     *   Default: wrapper-scripts=<resources>/wrapper_scripts
     */
    public static final String PROP_WRAPPER_SCRIPTS_DIR="wrapper-scripts";

    /**
     * Set 'require.password' as a server configuration parameter.
     *   Default: require.password=false
     */
    public static final String PROP_REQUIRE_PASSWORD="require.password";
    
    
    public static final String PROP_ANONYMOUS_ALLOWED="anonymous.users.allowed";
    
    /**
     * Set 'show.registration.link' to show the link to the registration page on the login page
     *   Default: show.registration.link=true
     */
    public static final String PROP_SHOW_REGISTRATION_LINK="show.registration.link";

    /**
     * Set 'show.terms.of.service' to show the terms of service on the registration page.
     *   Default: show.terms.of.service=false
     */
    public static final String PROP_SHOW_TERMS_OF_SERVICE="show.terms.of.service";

    /**
     * Set 'terms.of.service.link' to use an external link for the terms of service.
     *   Default: terms.of.service.link=
     */
    public static final String PROP_TERMS_OF_SERVICE_LINK="terms.of.service.link";

    /**
     * Set 'create.account.allowed' to true to allow users to create
     * new accounts from the login page
     *   Default: create.account.allowed=true
     */
    public static final String PROP_CREATE_ACCOUNT_ALLOWED="create.account.allowed";
    
    /**
     * Set the 'webmaster' as a server configuration parameter. 
     * 
     * Circa GP <= 3.9.11, the webmaster property is set when you install GenePattern.
     * The <webmaster> substitution is used by ... 
     *   1. the user email address saved to the registration database from the RegisterServerBean
     *   2. the username of the account created when you install GenePattern
     * 
     * @deprecated
     */
    public static final String PROP_WEBMASTER="webmaster";
    
    public static String normalizePath(String pathStr) {
        if (pathStr==null) {
            return pathStr;
        }
        try {
            Path thePath=Paths.get(pathStr);
            return Paths.get(thePath.toUri().getPath()).normalize().toUri().getPath();
        }
        catch (Throwable t) {
            System.err.print("Error intializing path from String="+pathStr);
            t.printStackTrace();
            return pathStr;
        }
    }
    
    /**
     * Get the current version of GenePattern, (e.g. '3.9.4'). 
     * Automatic schema update is based on the difference between this value (as defined by the GP installation)
     * and the entry in the database.
     * 
     */
    protected String initGenePatternVersion(GpContext gpContext) {
        String gpVersion;
        if (this.buildProperties!=null) {
            gpVersion=this.buildProperties.get("genepattern.version");
            if (!Strings.isNullOrEmpty(gpVersion)) {
                return gpVersion;
            }
        } 
        log.error("Error initializing genepattern.version from config, using hard-coded value");
        return "3.9.5";
    }
    
    /**
     * Initialize the GenePatternURL from System.property
     * @return
     */
    private static URL initGpUrl(GpServerProperties serverProperties) {
        log.debug("Initializing GenePatternURL from server properties ...");
        URL gpUrl=null;
        String urlStr = null;
        if (serverProperties != null) {
            urlStr=serverProperties.getProperty("GenePatternURL");
        }
        if (urlStr==null) {
            urlStr="http://127.0.0.1:8080/gp/";
        }
        try {
            gpUrl=new URL(urlStr);
        }
        catch (Throwable t) {
            log.error("Error initializing GenePatternURL="+urlStr);
            try {
                gpUrl=new URL("http://127.0.0.1:8080/gp/");
            }
            catch(Throwable t1) {
                throw new IllegalArgumentException("shouldn't ever be here", t1);
            }
        }
        if (log.isDebugEnabled()) {
            log.debug("GenePatternURL="+gpUrl);
        }
        return gpUrl;
    }

    private static GpRepositoryProperties initRepoConfig(final File resourcesDir) {
        return new GpRepositoryProperties.Builder()
            .resourcesDir(resourcesDir)
            .build();
    }

    private final File webappDir;
    private final File gpHomeDir;
    private final URL genePatternURL;
    private final String gpUrl;
    private final String gpServletContext;
    private final String genePatternVersion;
    private final File logDir;
    private final File gpLogFile;
    private final File webserverLogFile;
    private final File resourcesDir;
    private final File gpWorkingDir;
    private final File rootJobDir;
    private final File rootUserDir;
    private final File rootSoapAttachmentDir;
    private final File gpTmpDir;
    private final File gpPluginDir;
    private final List<Throwable> initErrors;
    private final GpRepositoryProperties repoConfig;
    private final GpServerProperties serverProperties;
    private final ConfigYamlProperties yamlProperties;
    private final File configFile;
    private final Properties dbProperties;
    private final Map<String,String> buildProperties;
    private final String dbVendor;

    /**
     *  Special-case, some properties can be set by convention rather than declared in a config file.
     *  For example,  patches=$GENEPATTERN_HOME$/patches
     *  When this is the case, save the lookup into the substitutionParams map when initializing the config.
     */
    private final Map<String,String> substitutionParams=new HashMap<String,String>();

    public GpConfig(final Builder in) {
        this.gpServletContext=in.gpServletContext;
        GpContext gpContext=GpContext.getServerContext();
        this.webappDir=in.webappDir;
        if (this.webappDir != null) {
            // init tools dir
            final File toolsDir=new File(webappDir, "WEB-INF/tools").getAbsoluteFile();
            this.substitutionParams.put(PROP_GP_TOOLS_DIR, toolsDir.getAbsolutePath());

            final File ant_1_8_HomeDir=new File(toolsDir, "ant/apache-ant-1.8.4").getAbsoluteFile();
            // <java> -Dant.home=<ant-1.8_HOME> -cp <ant-1.8_HOME>/lib/ant-launcher.jar org.apache.tools.ant.launch.Launcher
            final String antJavaCmd="<java> -Dant.home=<ant-1.8_HOME>"
                    +" -cp <ant-1.8_HOME>"+File.separator+"lib"+File.separator+"ant-launcher.jar"
                    +" org.apache.tools.ant.launch.Launcher";
            final String antScriptCmd="<ant-1.8_HOME>/bin/ant --noconfig";
            // by default, launch ant as a java command (antScriptCmd is here for demonstration purposes only)
            final String antCmd=antJavaCmd;
                    
            this.substitutionParams.put("ant-1.8_HOME", ant_1_8_HomeDir.getAbsolutePath());
            this.substitutionParams.put("ant-1.8", antCmd);
            this.substitutionParams.put("ant", antCmd);
            this.substitutionParams.put("ant-java", antJavaCmd);
            this.substitutionParams.put("ant-script", antScriptCmd);

            this.substitutionParams.put("run_r_path", new File(webappDir, "WEB-INF/classes").getAbsolutePath());
            if (in.resourcesDir != null) {
                this.substitutionParams.put("R.suppress.messages.file", new File(in.resourcesDir, "R_suppress.txt").getAbsolutePath());
            }
            
            // special-case, set execute flag for ant command
            File antPath=new File(ant_1_8_HomeDir,"bin/ant");
            if (!antPath.exists()) {
                log.warn("<ant-1.8> path doesn't exist: "+antPath);
            }
            else {
                if (!antPath.canExecute()) {
                    log.warn("<ant-1.8> is not executable: "+antPath);
                    log.warn("changing exec flag for <ant-1.8> to true");
                    boolean success=antPath.setExecutable(true);
                    if (!success) {
                        log.warn("unable to set exec flag for <ant-1.8>");
                    }
                }
            }
        }

        this.buildProperties=initBuildProperties();
        this.gpHomeDir=in.gpHomeDir;
        if (in.logDir!=null) {
            this.logDir=in.logDir;
        }
        else {
            this.logDir=initLogDir();
        }
        this.gpLogFile=new File(logDir, "genepattern.log");
        this.webserverLogFile=new File(logDir, "webserver.log");
        this.resourcesDir=in.resourcesDir;
        if (in.resourcesDir != null) {
            this.substitutionParams.put("resources", resourcesDir.getAbsolutePath());
        }
        // init 'wrapper-scripts'
        if (in.resourcesDir == null) {
            this.substitutionParams.put(PROP_WRAPPER_SCRIPTS_DIR, "<resources>/wrapper_scripts");
        }
        else {
            this.substitutionParams.put(PROP_WRAPPER_SCRIPTS_DIR, new File(resourcesDir, "wrapper_scripts").getAbsolutePath());
        }
        if (in.gpWorkingDir==null) {
            // legacy server, assume startup in <GenePatternServer>/Tomcat folder.
            this.gpWorkingDir=new File("").getAbsoluteFile();
        }
        else {
            this.gpWorkingDir=in.gpWorkingDir;
        }
        this.serverProperties=in.serverProperties;
        if (in.configFromYaml != null && in.configFromYaml.getConfigYamlProperties() != null) {
            this.yamlProperties=in.configFromYaml.getConfigYamlProperties();
        }
        else {
            this.yamlProperties=null;
        }

        if (in.genePatternURL!=null) {
            this.genePatternURL=in.genePatternURL;
        }
        else {
            this.genePatternURL=initGpUrl(this.serverProperties);
        }
        this.gpUrl=this.genePatternURL.toExternalForm();
        // must call this after initBuildProperties, because the version is loaded from the build.properties file
        this.genePatternVersion=initGenePatternVersion(gpContext);
        this.substitutionParams.put(PROP_GENEPATTERN_VERSION, genePatternVersion);
        this.substitutionParams.put(PROP_GENEPATTERN_VERSION_LEGACY, genePatternVersion);
        if (in.initErrors==null) {
            this.initErrors=Collections.emptyList();
        }
        else {
            this.initErrors=ImmutableList.copyOf(in.initErrors);
        }
        this.configFile=in.configFile;
        this.repoConfig=initRepoConfig(this.resourcesDir);
        this.rootJobDir=initRootDir(gpContext, GpConfig.PROP_JOBS, "jobResults", true);
        this.rootUserDir=initRootDir(gpContext, PROP_USER_ROOT_DIR, "users", true);
        this.rootSoapAttachmentDir=initRootDir(gpContext, GpConfig.PROP_SOAP_ATT_DIR, "temp/attachments", true);
        this.gpTmpDir=initGpTmpDir(gpContext);
        this.dbProperties=initDbProperties(gpContext, this.resourcesDir);
        this.dbVendor=initDbVendor(gpContext);
        if (in.rootPluginDir != null) {
            this.gpPluginDir=in.rootPluginDir;
        }
        else {
            this.gpPluginDir=initRootDir(gpContext, PROP_PLUGIN_DIR, "patches", true);
        }
    }
    
    /**
     * Get the file from the WEB-INF/build.properties file.
     * Circa GP <= 3.9.3, it was in resources directory.
     * 
     * @return the build.properties file
     */
    protected File getBuildPropertiesFile(final File webappDir) {
        File propFile=new File(webappDir, "WEB-INF/build.properties");
        if (!propFile.exists()) {
            log.warn("did not find 'build.properties' in WEB-INF folder");
            propFile=new File(resourcesDir, "build.properties");
        }
        return propFile;
    }
    
    protected Map<String,String> initBuildProperties() {
        if (webappDir==null) {
            log.error("webappDir is null, can't initialize build.properties");
            return Collections.emptyMap();
        }
        File buildPropFile=getBuildPropertiesFile(this.webappDir);
        if (buildPropFile.exists()) {
            final Properties buildProps=GpServerProperties.loadProps(buildPropFile);
            log.info("\tloaded build.properties from " + buildPropFile.getAbsolutePath()); 
            return ImmutableMap.copyOf(Maps.fromProperties(buildProps));
        }
        else {
            log.error("\t"+buildPropFile.getAbsolutePath()+" (No such file or directory)");
            return Collections.emptyMap();
        } 
    } 
    
    /**
     * Initialize the database properties from the resources directory.
     * Load properties from 'resources/database_default.properties', if present.
     * Load additional properties from 'resources/database_custom.properties', if present.
     * The custom properties take precedence.
     * 
     * When 'database.vendor=HSQL', attempt to set the jdbcUrl based on the value of the HSQL_port property.
     * 
     * If neither file is present, log an error and return null.
     * 
     */
    protected Properties initDbProperties(final GpContext gpContext, final File resourcesDir) {
        Properties hibProps=null;
        File hibPropsDefault=new File(resourcesDir, "database_default.properties");
        
        if (hibPropsDefault.exists()) {
            if (!hibPropsDefault.canRead()) {
                log.error("Can't read 'database_default.properties' file="+hibPropsDefault);
            }
            else {
                hibProps=GpServerProperties.loadProps(hibPropsDefault);
            }
        }
        File hibPropsCustom=new File(resourcesDir, "database_custom.properties");
        if (hibPropsCustom.exists()) {
            if (!hibPropsCustom.canRead()) {
                log.error("Can't read 'database_custom.properties' file="+hibPropsCustom);
            }
            else {
                if (hibProps==null) {
                    hibProps=new Properties();
                }
                GpServerProperties.loadProps(hibProps, hibPropsCustom);
            }
        }
        
        if (hibProps==null) {
            log.error("Error, missing required configuration file 'database_default.properties'");
            return null;
        }
        
        initHsqlConnectionUrl(gpContext, hibProps);
        return hibProps;
    }
    
    /**
     * Generate hard-coded database properties.
     */
    public Properties getDbPropertiesDefault(GpContext gpContext) {
        log.warn("Using hard-coded database properties");
        // use hard-coded DB properties
        Properties hibProps=new Properties();
        hibProps=new Properties();
        hibProps.setProperty("database.vendor","HSQL");
        hibProps.setProperty("HSQL_port","9001");
        hibProps.setProperty("hibernate.current_session_context_class","thread");
        hibProps.setProperty("hibernate.transaction.factory_class","org.hibernate.transaction.JDBCTransactionFactory");
        hibProps.setProperty("hibernate.connection.provider_class","org.hibernate.connection.C3P0ConnectionProvider");
        hibProps.setProperty("hibernate.jdbc.batch_size","20");
        hibProps.setProperty("hibernate.statement_cache.size","0");
        hibProps.setProperty("hibernate.connection.driver_class","org.hsqldb.jdbcDriver");
        hibProps.setProperty("hibernate.username","sa");
        hibProps.setProperty("hibernate.password","");
        hibProps.setProperty("hibernate.dialect","org.hibernate.dialect.HSQLDialect");
        hibProps.setProperty("hibernate.default_schema","PUBLIC");
        initHsqlConnectionUrl(gpContext, hibProps);
        return hibProps;
    }

    protected String initDbVendor(final GpContext gpContext) {
        if (dbProperties != null) {
            return dbProperties.getProperty(PROP_DATABASE_VENDOR, "HSQL");
        }
        else {
            return getGPProperty(gpContext, PROP_DATABASE_VENDOR, "HSQL");
        }
    }
    
    /**
     * Special-case for default database.vendor=HSQL, set the 'hibernate.connection.url' from the 'HSQL_port'.
     * @param gpConfig
     * @param gpContext
     * @param hibProps
     */
    private void initHsqlConnectionUrl(GpContext gpContext, Properties hibProps) {
        //special-case for default database.vendor=HSQL
        if ("hsql".equalsIgnoreCase(hibProps.getProperty(PROP_DATABASE_VENDOR))) {
            Integer hsqlPort=null;
            final String PROP_HSQL_PORT="HSQL_port";
            if (hibProps.containsKey(PROP_HSQL_PORT)) {
                try {
                    hsqlPort=Integer.parseInt( hibProps.getProperty(PROP_HSQL_PORT) );
                }
                catch (Throwable t) {
                    log.error("Error in config file, expecting an Integer value for "+PROP_HSQL_PORT+"="+hibProps.getProperty(PROP_HSQL_PORT), t);
                }
            }
            if (hsqlPort==null) {
                hsqlPort=getGPIntegerProperty(gpContext, PROP_HSQL_PORT, 9001);
            }
            final String PROP_HIBERNATE_CONNECTION_URL="hibernate.connection.url";
            if (!hibProps.containsKey(PROP_HIBERNATE_CONNECTION_URL)) {
                String jdbcUrl="jdbc:hsqldb:hsql://127.0.0.1:"+hsqlPort+"/xdb";
                hibProps.setProperty(PROP_HIBERNATE_CONNECTION_URL, jdbcUrl);
                log.debug("setting "+PROP_HIBERNATE_CONNECTION_URL+"="+jdbcUrl);
            }
        }
    }

    public static File relativize(final File rootDir, final String pathStr) {
        File path=new File(pathStr);
        if (path.isAbsolute()) {
            return path;
        }
        else if (rootDir != null) {
            return new File(rootDir, pathStr);
        }
        else {
            return path.getAbsoluteFile();
        }
    }
    
    /**
     * Convert the given file path into an absolute path if necessary.
     * If GP_HOME is set, assume the path is relative to GP_HOME,
     * else  assume the path is relative to GP_WORKING_DIR.
     * 
     */
    protected File initAbsolutePath(final String pathOrRelativePath) { 
        final File rootDir;
        if (this.gpHomeDir != null) {
            rootDir=this.gpHomeDir;
        }
        else {
            rootDir=this.gpWorkingDir;
        }
        File f = relativize(rootDir, pathOrRelativePath);
        f = new File(normalizePath(f.getPath()));
        return f;
    }
    
    /**
     * Helper method for initializing an absolute path to a data file directory, for example for the 'patches' or 'taskLib'.
     * This takes care of legacy support where data file paths were declared in the genepattern.properties file as relative
     * paths to the working directory for the application server, e.g.
     *     patches=../patches
     *     tasklib=../taskLib
     * 
     * When GENEPATTERN_HOME is defined, default paths are in the GENEPATTERN_HOME directory.
     * When not defined, default paths are one level up from the GENEPATTERN_WORKING_DIRECTORY.
     * 
     * @param serverContext a valid server context
     * @param propName the name of the property (optionally loaded from the config file)
     * @param defaultDirName the default file system name for the data directory.
     * 
     */
    protected File initRootDir(final GpContext serverContext, final String propName, String defaultDirName, final boolean mkdirs) {
        String dirProp=getGPProperty(serverContext, propName);
        boolean isSubstitutionParam=false;
        if (dirProp == null) {
            isSubstitutionParam=true;
            if (gpHomeDir != null) {
                dirProp=defaultDirName;
            }
            else if (gpWorkingDir != null) {
                dirProp="../"+defaultDirName;
            }
        }
        File f=initAbsolutePath(dirProp);
        if (isSubstitutionParam) {
            this.substitutionParams.put(propName, ""+f);
        }
        if (mkdirs) {
            if (!f.exists()) {
                boolean success=f.mkdirs();
                if (success) {
                    log.info("created '"+propName+"' directory="+f);
                }
                else {
                    log.error("failed to create '"+propName+"' directory="+f);
                }
            }
        }
        return f;
    }
    
    
    /**
     * Initialize the global path to the temp directory.
     * If {@link GpConfig#PROP_GP_TMPDIR} is defined use that value.
     * Else if 'java.io.tmpdir' is set in the 'genepattern.properties' file use that value.
     * Else if gpHomeDir is not null use gpHomeDir/temp
     * Else if gpWorkingDir is not null use gpWorkingDir/temp
     * Else use 'java.io.tempdir'.
     * 
     */
    protected File initGpTmpDir(final GpContext gpContext) {
        String prop=getGPProperty(gpContext, GpConfig.PROP_GP_TMPDIR);
        if (prop != null) {
            return initRootDir(gpContext, GpConfig.PROP_GP_TMPDIR, "temp", true);
        }
        //special-case for legacy servers
        if (serverProperties != null) {
            if (serverProperties.isSetInGpProperties("java.io.tmpdir")) {
                return this.initAbsolutePath(serverProperties.getProperty("java.io.tmpdir"));
            }
        }
        
        if (gpHomeDir != null) {
            return new File(gpHomeDir, "temp");
        }
        else if (gpWorkingDir != null) {
            return new File(gpWorkingDir, "temp");
        }
        return new File(System.getProperty("java.io.tmpdir"));
    }

    /**
     * Get the public facing URL for this GenePattern Server.
     */
    public URL getGenePatternURL() {
        return genePatternURL;
    }

    /**
     * Get the String representation of the <GenePatternURL>, including the trailing slash.
     */
    public String getGpUrl() {
        return gpUrl;
    }
    
    /**
     * Get the servlet context.
     */
    public String getGpPath() {
        return gpServletContext;
    }

    public String getGenePatternVersion() {
        return genePatternVersion;
    }

    public File getConfigFile() {
        return configFile;
    }

    public String getConfigFilepath() {
        if (configFile != null) {
            return configFile.getAbsolutePath();
        }
        return null;
    }

    public boolean hasInitErrors() {
        return initErrors != null && initErrors.size()>0;
    }

    public List<Throwable> getInitializationErrors() {
        return initErrors;
    }
    public File getResourcesDir() {
        return resourcesDir;
    }

    /**
     * Get the read-only map of properties loaded from the WEB-INF/build.properties file.
     */
    public Map<String,String> getBuildProperties() {
        return  buildProperties;
    }

    /**
     * Get the 'default' command prefix declared in the resources/commandPrefix.properties file.
     */
    public String getDefaultCommandPrefix() {
        return Strings.nullToEmpty(
            serverProperties
                .getCommandPrefixProps()
                .getProps().get("default")
        );
    }

    /**
     * Get the properties loaded from the resources/commandPrefix.properties file.
     */
    protected Record getCommandPrefixProps() {
        return serverProperties.getCommandPrefixProps();
    }

    /**
     * Get the properties loaded from the resources/taskPrefixMapping.properties file.
     */
    protected Record getTaskPrefixMappingProps() {
        return serverProperties.getTaskPrefixMappingProps();
    }

    /**
     * Get the database configuration properties loaded from the <resources>/database_default.properties and
     * optionally from the <resources>/database_custom.properties files.
     */
    public Properties getDbProperties() {
        return dbProperties;
    }

    /**
     * Get the database vendor which can be one of 'HSQL', 'ORACLE', or 'MYSQL'.
     */
    public String getDbVendor() {
        return dbVendor;
    }

    /**
     * Get the database schema prefix, a prefix pattern (e.g. 'analysis_hypersonic', 'analysis_oracle') 
     * which is used to get a listing of the DDL scripts for automatic initialization of the database after
     * installing or updating the genepattern server.
     */
    public String getDbSchemaPrefix() {
        return getDbSchemaPrefix(this.dbVendor);
    }
    
    protected static String getDbSchemaPrefix(final String dbVendor) {
        if (dbVendor.equalsIgnoreCase("HSQL")) {
            return "analysis_hypersonic-";
        }
        else {
            return "analysis_"+dbVendor.toLowerCase()+"-";
        }
    }

    /**
     * Get the 'lsid.authority'.
     * 
     * @return String
     * @see #PROP_LSID_AUTHORITY
     */
    public String getLsidAuthority(final GpContext gpContext) {
        final String DEFAULT_LSID_AUTHORITY="broad-cancer-genomics";
        return this.getGPProperty(gpContext, PROP_LSID_AUTHORITY, DEFAULT_LSID_AUTHORITY);
    }

    /**
     * Are passwords required?
     *   Default: false
     */
    public boolean isPasswordRequired(final GpContext serverContext) {
        return getGPTrueProperty(serverContext, PROP_REQUIRE_PASSWORD, false);
    }

    /**
     * Do we allow anonymous users?
     *    Default: false
     */
    public boolean isAnonymousAllowed(final GpContext serverContext) {
        return getGPTrueProperty(serverContext, PROP_ANONYMOUS_ALLOWED, false);
    }
    
    /**
     * Show the link to the registration page on the login page?
     *   Default: true
     */
    public boolean isShowRegistrationLink(final GpContext serverContext) {
        return getGPTrueProperty(serverContext, PROP_SHOW_REGISTRATION_LINK, true); 
    }

    /**
     * Can users create new accounts from the login page?
     *   Default: true
     */
    public boolean isCreateAccountAllowed(final GpContext serverContext) {
        return getGPTrueProperty(serverContext, PROP_CREATE_ACCOUNT_ALLOWED, true);
    }

    protected Value getValueFromConfig(final GpContext context, final String key) {
        Value value=null;
        if (yamlProperties != null) {
            value=yamlProperties.getValue(context, key);
        }
        if (value==null && serverProperties != null) {
            value=serverProperties.getValue(context, key);
        }

        return value;
    }

    public Value getValue(final GpContext context, final String key) {
        Value value=getValueFromConfig(context, key);
        if (value != null) {
            return value;
        }
        // special-case for built-in substitution parameters
        final String substitutionValue=this.substitutionParams.get(key);
        if (substitutionValue!=null) {
            return new Value(substitutionValue);
        }
        // special-case for 'job.docker.image'
        if (value==null && JobRunner.PROP_DOCKER_IMAGE.equals(key)) {
            value=GpConfig.lookupJobDockerImageValue(this, context);
        }
        return value;
    }

    public Value getValue(final GpContext context, final String key, final Value defaultValue) {
        Value value=getValue(context, key);
        if (value==null) {
            return defaultValue;
        }
        return value;
    }

    /** 
     * generic implementation of getOrDefault which works in Java 1.7.
     * Use as an alternative to the similar method in the Map interface. 
     *     // requires Java 1.8+
     *     map.getOrDefault(key, defaultValue)
     *     // works with Java 1.7
     *     GpConfig.getOrDefault(map, key, defaultValue); 
     */
    public static final <K,V> V getOrDefault(final Map<K,V> map, K key, V defaultValue) {
        V value=map.get(key);
        if (value != null) {
            return value;
        }
        return defaultValue;
    }

    /**
     * Get java system property.
     */
    public static String getJavaProperty(final String key) {
        return System.getProperty(key);
    }
    
    /**
     * Get java system property.
     * @param key the name of a system property
     * @param def a default value
     * @return the string value of the system property, or the default value if there is no property with that key
     */
    public static String getJavaProperty(final String key, final String def) {
        return System.getProperty(key, def);
    }

    /**
     * Get the value from the 'build.properties' file.
     */
    public String getBuildProperty(final String key) {
        return getBuildProperty(key, null);
    }

    /**
     * Get the value from the 'build.properties' file, or the default value.
     */
    public String getBuildProperty(final String key, final String defaultValue) {
        if (this.buildProperties==null) {
            return defaultValue;
        }
        String rval=this.buildProperties.get(key);
        if (rval != null) {
            return rval;
        }
        return defaultValue;
    } 

    /**
     * Get a String property from this configuration or null if the property is not set.
     * 
     * @see #getValue(GpContext, String) to load more complex data structures,
     * such as a List or a Map, from the config_custom.yaml file.
     * 
     * @param context the configuration context
     * @param key the property key
     * 
     * @return the config value with the specified key
     */
    public String getGPProperty(final GpContext context, final String key) {
        return getGPProperty(context, key, null);
    }

    public String getGPProperty(final GpContext context, final String key, final String defaultValue) {
        final Value value = getValue(context, key);
        if (value == null) {
            return defaultValue;
        }
        if (value.getNumValues() > 1) {
            log.error("returning first item of a "+value.getNumValues()+" item list");
        }
        return value.getValue();
    }

    /**
     * Helper method which accepts "true" | "yes" | "y" as True
     * and all others as false
     * @param prop
     * @return
     */
    public static boolean isTrue(final String prop) {
        return prop != null && (
               prop.equalsIgnoreCase("true")
           || prop.equalsIgnoreCase("y") 
           || prop.equalsIgnoreCase("yes")
        );
    }

    /**
     * Utility method for parsing a property as a true/false value.
     * Special-case for legacy properties which can be configured as 'true', 'yes' or 'y'
     */
    public boolean getGPTrueProperty(final GpContext gpContext, final String key, final boolean defaultValue) {
        final String prop = getGPProperty(gpContext, key);
        if (prop==null) {
            return defaultValue;
        }
        return isTrue(prop);
    }

    /**
     * Utility method for parsing properties as a boolean.
     * The current implementation uses Boolean.parseBoolean,
     * which returns true iff the property is set and equalsIgnoreCase 'true'.
     *
     */
    public boolean getGPBooleanProperty(final GpContext context, final String key) {
        String prop = getGPProperty(context, key);
        return Boolean.parseBoolean(prop);
    }

    public boolean getGPBooleanProperty(final GpContext context, final String key, final boolean defaultValue) {
        String prop = getGPProperty(context, key);
        if (prop == null) {
            return defaultValue;
        }
        return Boolean.parseBoolean(prop);
    }

    /**
     * Utility method for parsing a property as an Integer. If there is no property set
     * return null.
     *
     * When a non integer value is set in the config file, return null.
     * Errors are logged, but exceptions are not thrown.
     *
     */
    public Integer getGPIntegerProperty(final GpContext context, final String key) {
        return getGPIntegerProperty(context, key, null);
    }

    /**
     * Utility method for parsing a property as an Integer.
     *
     * When a non integer value is set in the config file, the default value is returned.
     * Errors are logged, but exceptions are not thrown.
     *
     * @return the int value for the property, or the default value, can return null.
     */
    public Integer getGPIntegerProperty(final GpContext context, final String key, final Integer defaultValue) {
        String val = getGPProperty(context, key);
        if (val == null) {
            return defaultValue;
        }
        try {
            return Integer.parseInt(val);
        }
        catch (NumberFormatException e) {
            log.error("Error parsing integer value for property, "+key+"="+val);
            return defaultValue;
        }
    }

    public Long getGPLongProperty(final GpContext context, final String key, final Long defaultValue) {
        String val = getGPProperty(context, key);
        if (val == null) {
            return defaultValue;
        }
        try {
            return Long.parseLong(val);
        }
        catch (NumberFormatException e) {
            log.error("Error parsing long value for property, "+key+"="+val);
            return defaultValue;
        }
    }

    public BigDecimal getGPBigDecimalProperty(final GpContext gpContext, final String key) {
        return getGPBigDecimalProperty(gpContext, key, null);
    }

    public BigDecimal getGPBigDecimalProperty(final GpContext gpContext, final String key, final BigDecimal defaultValue) {
        final String val = getGPProperty(gpContext, key);
        if (Strings.isNullOrEmpty(val)) {
            return defaultValue;
        }
        try {
            return new BigDecimal(val);
        }
        catch (NumberFormatException e) {
            log.error("Error parsing numerical value for property, "+key+"='"+val+"'", e);
            return defaultValue;
        }
    }

    public Memory getGPMemoryProperty(final GpContext gpContext, final String key) {
        return getGPMemoryProperty(gpContext, key, null);

    }

    public Memory getGPMemoryProperty(final GpContext gpContext, final String key, final Memory defaultValue) {
        String val = getGPProperty(gpContext, key);
        if (val == null) {
            return defaultValue;
        }
        try {
            return Memory.fromString(val);
        }
        catch (Throwable t) {
            log.error("Error parsing memory value for property, "+key+"="+val, t);
            return defaultValue;
        }
    }
    
    /** 
     * Get the 'job.docker.image' substitution for a job based on the following conditions.
     * <ul>
     *   <li>the 'job.docker.image' in the manifest file</li>
     *   <li>the 'job.docker.image' in the config_yaml file</li>
     *   <li>the 'job.docker.image.default' in the config_yaml file</li>
     *   <li>the 'job.docker.image.lookup' in the config_yaml file</li>
     *   <li>the hard-coded default value, if not set anywhere else</li>
     * </ul>
     * 
     * <h3>Default</h3>
     * <p>By default use the 'job.docker.image' declared in the manifest file.</p>
     * 
     * <h3>Special case: No image in manifest</h3>
     * <p>There are two ways to set the docker image when there is no value in the manifest.</p>
     * <ol>
     *   <li>use the 'job.docker.image.lookup' table</li>
     *   <li>set the 'job.docker.image.default' property</li>
     * </ol>
     * <p>When there is no value in the manifest, set the 'job.default.docker.image' in the manifest
     *    file.
     * </p>
     * <p>The 'job.docker.image.lookup' can be used for older GenePattern modules which do not set the
     * docker image in the manfest file. Example:
     * </p>
     * <pre>
        job.docker.image.lookup: {
          # {taskName_no_version} : {dockerImage}
          "ExampleLookup": "genepattern/docker-example:1-lookup-name-no-version",

          # {taskName:version}    : {dockerImage}
          "ExampleLookup:1" : "genepattern/docker-example:1",
          
          # ExampleLookup
          # {lsid}                : {dockerImage}
          "urn:lsid:example.com:example.module.analysis:00003:2": "genepattern/docker-example:2",

          # ExampleLookup    
          # {lsid_no_version}     : {dockerImage}
          "urn:lsid:example.com:example.module.analysis:00003": "genepattern/docker-example:3",
          
          # Example 
          "Example:3.1": "genepattern/docker-example:3.1-from-lookup"
        }
     * </pre>
     * 
     * <h3>Special case: Override the value from the manifest</h3>
     * <p>If you need to use a different value than that which is set in the manifest file, 
     *    set the 'job.docker.image' in the config_yaml file. This will override the value,
     *    if any, that is set in the manifest file.
     * </p>
     * 
     * <h3>Precedence rules</h3>
     * <p>The 'job.docker.image' param takes precedence over 'job.docker.image.default'
     *    which takes precedence over 'job.docker.image.lookup'.
     * </p>
     * <p>In all cases the normal precedence rules for the config_yaml file apply. For example
     *    a custom value per user will override the default value.
     * </p>
     */
    public String getJobDockerImage(final GpContext gpContext) {
        return getGPProperty(gpContext, PROP_DOCKER_IMAGE);
    }

    public static final Value lookupJobDockerImageValue(final GpConfig gpConfig, final GpContext jobContext) {
        final Value lookup=gpConfig.getValue(jobContext, PROP_DOCKER_IMAGE_LOOKUP);
        if (lookup != null) {
            if (!lookup.isMap()) {
                log.error("ignoring '"+PROP_DOCKER_IMAGE_LOOKUP+"', expecting a value of type Map");
            }
            else {
                final Map<?,?> map=lookup.getMap();
                final String lsid=jobContext.getLsid();
                final String taskName=jobContext.getTaskName();
                String lsidNoVersion=null;
                String taskNameVersion=null;

                try {
                    LSID lsidObj=new LSID(lsid);
                    lsidNoVersion=lsidObj.toStringNoVersion();
                    if (lsidObj.hasVersion()) {
                        taskNameVersion=taskName+":"+lsidObj.getVersion();
                    }
                }
                catch (Throwable t) {
                    log.error(t);
                }
                if (map.containsKey(lsid)) {
                    return new Value(map.get(lsid).toString());
                }
                else if (taskNameVersion != null && map.containsKey(taskNameVersion)) {
                    return new Value(map.get(taskNameVersion).toString());
                    
                }
                else if (lsidNoVersion != null && map.containsKey(lsidNoVersion)) {
                    return new Value(map.get(lsidNoVersion).toString());
                }
                else if (map.containsKey(taskName)) {
                    return new Value(map.get(taskName).toString());
                } 
            }
        }
        log.warn("no match in '"+PROP_DOCKER_IMAGE_LOOKUP+"', trying '"+PROP_DOCKER_IMAGE_DEFAULT+"'");
        final String dockerImageDefault=gpConfig.getGPProperty(jobContext, PROP_DOCKER_IMAGE_DEFAULT, "genepattern/docker-java17:0.12");
        return new Value(dockerImageDefault);
    }

    /**
     * Get the queueId for a job, this is the value which should be logged into the 'job_runner_job' table in the GP database.
     * This method was added to support the 'job.virtualQueue' feature.
     * 
     * Use the getGPProperty(gpContext, JobRunner.PROP_QUEUE) method to get the actual queue name to be submitted to an external queuing system.
     * 
     * The default value is the empty string when neither property is set.
     *
     */
    public String getQueueId(final GpContext gpContext) {
        return getQueueId(gpContext, "");
    }

    public String getQueueId(final GpContext gpContext, final String defaultValue) {
        String queueId=getGPProperty(gpContext, JobRunner.PROP_VIRTUAL_QUEUE);
        if (queueId!=null) {
            return queueId;
        }
        queueId=getGPProperty(gpContext, JobRunner.PROP_QUEUE);
        if (queueId!=null) {
            return queueId;
        }
        return defaultValue;
    }
    
    /**
     * Get the optional command line prefix for a job.
     * 
     * @throws IllegalArgumentException
     */
    public String getCommandPrefix(final GpContext jobContext) 
    throws IllegalArgumentException, MalformedURLException
    {
        if (jobContext==null) {
            throw new IllegalArgumentException("jobContext is null");
        }
        final boolean isCommandLineJob = TaskType.JOB == jobContext.getTaskType();
        if (isCommandLineJob) {
            // get the 'job.commandPrefix' from the config_yaml file
            final String custom_prefix=this.getGPProperty(jobContext, PROP_JOB_COMMAND_PREFIX);
            if (!Strings.isNullOrEmpty(custom_prefix)) {
                return custom_prefix;
            }
        }
        final String lsidStr = jobContext.getLsid();
        return CommandPrefixConfig.getCommandPrefix(this, isCommandLineJob, lsidStr);
    }

    //helper methods for locating server files and folders
    /**
     * The location for the web application files, e.g.
     *     /Applications/GenePatternServer/Tomcat/webapps/gp
     */
    public File getWebappDir() {
        return this.webappDir;
    }
    
    /**
     * Get the GENEPATTERN_HOME directory, should be a fully qualified File, can be null when not set.
     * Servers updated from <= 3.9.1 don't set GENEPATTERN_HOME.
     */
    public File getGpHomeDir() {
        return this.gpHomeDir;
    }

    /**
     * Get the default working directory for the server.
     * 
     * @deprecated required for legacy GP servers. Newer GP servers should use GENEPATTERN_HOME.
     * 
     */
    protected File getGpWorkingDir() {
        return this.gpWorkingDir;
    }
    
    /**
     * Get the 'users' folder for the server. This is a global server property.
     */
    protected File getRootUserDir() {
        return rootUserDir;
    }
    
    /**
     * Get the 'home directory' for a gp user account. This is the location for user data.
     * By default, user home directories are created in the <user.root.dir> directory.
     * The 'gp.user.dir' property can be set on a per user basis to change the default location.
     *
     * Note: If an admin sets a custom 'gp.user.dir' for an existing user, they must manually migrate pre-existing files.
     *     (1) Move existing files into the correct 'gp.user.dir'
     *     (2) Resync Files from the Adminstration -> Server Settings -> Uploaded Files page
     */
    public File getUserDir(final GpContext context) {
        if (context == null) {
            throw new IllegalArgumentException("context is null");
        }
        if (context.getUserId() == null) {
            throw new IllegalArgumentException("context.userId is null");
        }
        String userDirPath = getGPProperty(context, "gp.user.dir");
        File gpUserDir;
        if (userDirPath != null) {
            gpUserDir=new File(userDirPath);
        }
        else {
            gpUserDir=new File(rootUserDir, context.getUserId());
        }
        if (gpUserDir.exists()) {
            return gpUserDir;
        }
        boolean success = gpUserDir.mkdirs();
        if (!success) {
            throw new IllegalArgumentException("Unable to create home directory for user "+context.getUserId()+", userDir="+gpUserDir.getAbsolutePath());
        }
        return gpUserDir;
    }

    /**
     * Get the job results directory for the server. This is a global server property.
     * In GP > 3.9.0, the default location is the GenePattern installation directory,
     *     <GenePatternServer>/jobResults
     * 
     * In GP <= 3.9.0 and earlier, the default location is the web application directory,
     *     <GenePatternServer>/Tomcat/webapps/gp/jobResults
     *
     * The 'jobs' property sets an alternate location. For best results set this to a global path in the 
     * 'default' section of the config_yaml file.
     * 
     * Note: Custom settings are not enabled.
     *
     * @return the parent directory in which to create the new working directory for a job.
     */
    public File getRootJobDir(final GpContext context) throws ServerConfigurationException {
        return rootJobDir;
    }

    /**
     * Get the upload directory for the given user, the location for files uploaded directly from the Uploads tab.
     * By default, user uploads are stored in ../users/<user.id>/uploads/
     *
     * The default location can be overridden with the 'user.upload.dir' property.
     * If there is no 'user.upload.dir' or 'gp.user.dir' set, then 'java.io.tempdir' is returned.
     *
     * @throws IllegalArgumentException if a directory is not found for the userId.
     */
    public File getUserUploadDir(final GpContext context) throws IllegalArgumentException {
        boolean configError = false;
        if (context == null) {
            configError = true;
            //throw new IllegalArgumentException("context is null");
            log.error("context is null");
        }
        else if (context.getUserId() == null) {
            configError = true;
            //throw new IllegalArgumentException("context.userId is null");
            log.error("context.userId is null");
        }

        if (configError) {
            return getTempDir(null);
        }

        String userUploadPath = getGPProperty(context, "user.upload.dir");
        if (userUploadPath == null) {
            File userDir = getUserDir(context);
            if (userDir != null) {
                File f = new File(userDir, "uploads");
                userUploadPath = f.getPath();
            }
        }

        File userUploadDir = new File(userUploadPath);
        if (userUploadDir.exists()) {
            return userUploadDir;
        }
        boolean success = userUploadDir.mkdirs();
        if (success) {
            return userUploadDir;
        }

        //otherwise, use the web upload dir
        log.error("Unable to create user.uploads directory for '"+context.getUserId()+"', userUploadDir="+userUploadDir.getAbsolutePath());
        return getTempDir(null);
    }
    
    /**
     * Get the globally configured location for installing plugins (aka patches). In GP <= 3.9.1 
     * this is defined in the 'genepattern.properties' file via the template:
     * <pre>
$USER_INSTALL_DIR$/patches
     * </pre>
     * In newer installations it should not be declared in the properties or config file. 
     * It is defined relative to GENEPATTERN_HOME:
     * <pre>
$GENEPATTERN_HOME$/patches
     * </pre>
     * @param serverContext the server context
     * @return the globally configured 'patches' directory
     */
    public File getRootPluginDir(GpContext serverContext) {
        return gpPluginDir;
    }
    
    /**
     * Get the globally configured location for installing modules and pipelines.
     * In GP <= 3.9.1 this is defined in the 'genepattern.properties' file via the template:
     * <pre>
tasklib=$USER_INSTALL_DIR$/taskLib
     * </pre>
     * In newer versions of GP, the default location is relative to GENEPATTERN_HOME:
     * <pre>
$GENEPATTERN_HOME$/tasklib
     * </pre>
     * The 'tasklib' property can be overwritten in the config_yaml file.
     * <pre>
    tasklib: /fully/qualified/path/to/tasklib
     * </pre>
     * 
     * @param serverContext the server context
     * @return the globally configured 'taskLib' directory
     */
    public File getRootTasklibDir(GpContext serverContext) {
        return initRootDir(serverContext, PROP_TASKLIB_DIR, "taskLib", true);
    }

    public File getGPFileProperty(final GpContext gpContext, final String key) {
        return getGPFileProperty(gpContext, key, null);
    }

    public File getGPFileProperty(final GpContext gpContext, final String key, final File defaultValue)
    {
        Value val = getValue(gpContext, key);

        if (val == null) {
            return defaultValue;
        }

        try {
            return new File(val.getValue());
        }
        catch (Throwable t) {
            log.error("Error parsing file value for property, "+key+"="+val, t);
            return defaultValue;
        }
    }

    public File getSoapAttDir(GpContext gpContext) {
        return this.rootSoapAttachmentDir;
    }

    public File getTempDir(GpContext gpContext) {
        return gpTmpDir;
    }

    private File initLogDir() 
    {
        File logDir = null;
        if(System.getProperty("GENEPATTERN_HOME") != null)
        {
            logDir = new File(System.getProperty("GENEPATTERN_HOME"), "logs");
        }
        else
        {
            logDir = new File("../logs");
        }

        return logDir;
    }

    public File getGPLogFile(GpContext gpContext)
    {
        return gpLogFile;
    }

    public File getWsLogFile(GpContext gpContext)
    {
        return webserverLogFile;
    }

    public boolean getAllowInputFilePaths(final GpContext context) {
        return getGPBooleanProperty(context, "allow.input.file.paths", false);
    }

    public File getTemporaryUploadDir(final GpContext context) throws IOException, Exception {
        String username = context.getUserId();
        if (username == null || username.length() == 0) {
            throw new Exception("userid not set");
        }

        File serverTempDir = getTempDir(null);
        // prefix is used to restrict access to input files based on username
        String prefix = username + "_";
        File tempDir = File.createTempFile(prefix + "run", null, serverTempDir);
        tempDir.delete();
        tempDir.mkdir();
        return tempDir;
    }

    public Set<String> getRepositoryUrls() {
        if (repoConfig==null) {
            return Collections.emptySet();
        }
        return repoConfig.getRepositoryUrls();
    }
    public RepositoryInfo getRepositoryInfo(final String url) {
        if (repoConfig==null) {
            return null;
        }
        return repoConfig.getRepositoryInfo(url);
    }

    /**
     * @deprecated deprecated
     */
    public JobConfigObj getJobConfiguration() {
        if (yamlProperties==null) {
            return null;
        }
        return yamlProperties.getJobConfiguration();
    }

    public String getExecutorId(final GpContext gpContext) {
        //special-case for pipelines
        if (gpContext != null && gpContext.getTaskInfo() != null) {
            final boolean isPipeline=gpContext.getTaskInfo().isPipeline();
            if (isPipeline) {
                return CommandExecutorMapper.PIPELINE_EXEC_ID;
            }
        }
        return getGPProperty(gpContext, "executor");
    }
    /**
     * For the case where we want to have a fail-over executor such as when
     * delegating to another GP server such as  gp@ucsd which is less reliable
     * than, say, AWS
     * @param gpContext
     * @return
     */
    public String getFailoverExecutorId(final GpContext gpContext) {
        //special-case for pipelines
        if (gpContext != null && gpContext.getTaskInfo() != null) {
            final boolean isPipeline=gpContext.getTaskInfo().isPipeline();
            if (isPipeline) {
                return CommandExecutorMapper.PIPELINE_EXEC_ID;
            }
        }
        return getGPProperty(gpContext, "failover_executor");
    }
    

    /**
     * @deprecated should just call getValue(GpContext jobContext, "executor")
     */
    public String getCommandExecutorId(final JobInfo jobInfo) {
        if (yamlProperties == null) {
            return null;
        }
        return yamlProperties.getCommandExecutorId(jobInfo);
    }

    /**
     * @deprecated should make direct calls to getValue with a jobContext instead.
     */
    public CommandProperties getCommandProperties(JobInfo jobInfo) {
        if (yamlProperties == null) {
            return null;
        }
        return yamlProperties.getCommandProperties(jobInfo);
    }

    public static final class Builder {
        private String gpServletContext="/gp";
        private URL genePatternURL=null;
        private File webappDir=null;
        private File gpHomeDir=null;
        private File logDir=null;
        private File resourcesDir=null;
        private File rootPluginDir=null;
        private File configFile=null;
        private File gpWorkingDir=null;
        private GpServerProperties.Builder serverPropertiesBuilder=null;
        private GpServerProperties serverProperties=null;
        private ConfigFromYaml configFromYaml=null;
        private IGroupMembershipPlugin groupInfo=null;
        private List<Throwable> initErrors=null;

        public Builder() {
        }
        
        public Builder gpServletContext(final String gpServletContext) {
            this.gpServletContext=gpServletContext;
            return this;
        }

        public Builder genePatternURL(final URL gpUrl) {
            this.genePatternURL=gpUrl;
            return this;
        }
        public Builder addError(final Throwable t) {
            if (initErrors==null) {
                initErrors=new ArrayList<Throwable>();
            }
            initErrors.add(t);
            return this;
        }

        public Builder serverProperties(final GpServerProperties serverProperties) {
            this.serverProperties=serverProperties;
            return this;
        }
        
        public Builder webappDir(final File webappDir) {
            this.webappDir=webappDir;
            return this;
        }

        public Builder gpHomeDir(final File gpHomeDir) {
            this.gpHomeDir=gpHomeDir;
            return this;
        }

        public Builder gpWorkingDir(final File gpWorkingDir) {
            this.gpWorkingDir=gpWorkingDir;
            return this;
        }
        
        public Builder logDir(final File logDir) {
            this.logDir=logDir;
            return this;
        }

        public Builder resourcesDir(final File resourcesDir) {
            this.resourcesDir=resourcesDir;
            return this;
        }
        
        public Builder rootPluginDir(final File rootPluginDir) {
            this.rootPluginDir=rootPluginDir;
            return this;
        }

        public Builder configFile(final File configFile) {
            this.configFile=configFile;
            return this;
        }

        public Builder groupInfo(final IGroupMembershipPlugin groupInfo) {
            this.groupInfo=groupInfo;
            return this;
        }

        public Builder addProperties(Properties props) {
            for(final Object keyObj : props.keySet()) {
                String key = keyObj.toString();
                addProperty(key, props.getProperty(key));
            }
            return this;
        }
        
        public Builder addProperties(Map<String,String> map) {
            for(final Entry<String,String> entry : map.entrySet()) {
                addProperty(entry.getKey(), entry.getValue());
            }
            return this;
        }
        
        public Builder addProperty(String key, String value) {
            if (serverPropertiesBuilder==null) {
                serverPropertiesBuilder=new GpServerProperties.Builder();
            }
            serverPropertiesBuilder.addCustomProperty(key, value);
            return this;
        }

        public GpConfig build() {
            //parse the config file here
            if (configFile != null) {
                try {
                    configFromYaml=ConfigFileParser.parseYamlFile(configFile, groupInfo);
                }
                catch (ConfigurationException e) {
                    addError(e);
                }
            }

            //if not already set, set the resourcesDir
            if (resourcesDir == null) {
                if (configFile != null) {
                    resourcesDir=configFile.getParentFile();
                }
                else if (serverProperties != null) {
                    resourcesDir=serverProperties.getResourcesDir();
                }
                else if (gpHomeDir != null) {
                    resourcesDir=new File(gpHomeDir,"resources");
                }
            }

            if (serverProperties==null && serverPropertiesBuilder != null) {
                serverProperties=serverPropertiesBuilder.build();
            }

            return new GpConfig(this);
        }
    }
}
