/*******************************************************************************
 * Copyright (c) 2003-2022 Regents of the University of California and Broad Institute. All rights reserved.
 *******************************************************************************/

package org.genepattern.server;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;
import org.genepattern.server.user.User;

import com.google.common.base.Strings;

public class EncryptionUtil {
    /**
     * Property name for the key used to lookup the dynamically generated key for mapping a
     */
    public static final String PROP_PIPELINE_USER_KEY = "pipeline.user.key";
    private static Logger log = Logger.getLogger(EncryptionUtil.class);

    /**
     * Cache the result of encrypted the empty string ("").
     */
    private static byte[] EMPTY = new byte[0];

    private static EncryptionUtil instance = new EncryptionUtil();

    /**
     * Map a system generated key to a user's encrypted password.
     */
    private Map<String, byte[]> pipelineUserKeys = new HashMap<String, byte[]>();

    private EncryptionUtil() {
    }

    /**
     * Retrieve the user's encrypted password given the key generated by pushPipelineUserKey.
     * 
     * @param key
     * @return a user's encrypted password
     * 
     * @see {@link #pushPipelineUserKey(User)}
     */
    public byte[] getPipelineUserEncryptedPassword(String key) {
	return pipelineUserKeys.get(key);
    }

    /**
     * Save the user's encrypted password so that is is retrievable via the generated key. Generates a unique key and
     * stores the user's encrypted password into system memory. The intention is remove this key and associated value
     * from memory when it is no longer needed. This is so that nested pipelines will work when user passwords are
     * required.
     * 
     * @param user
     * @return the generated key.
     */
    public String pushPipelineUserKey(User user) {
        String key = "";
        if (user == null) {
            log.error("Null arg (user) in pushPipelineUserKey");
        }
        else {
            key += user.getUserId();
        }
        key += "." + System.currentTimeMillis();
        try {
            byte[] encryptedKey = encrypt(key);
            key = convertToString(encryptedKey);
        } 
        catch (NoSuchAlgorithmException e) {
            log.error("Warning: unable to encrypt system generated key", e);
        }
        pipelineUserKeys.put(key, user.getPassword());
        return key;
    }

    /**
     * Remove the user's encrypted password associated with the given key.
     * 
     * @param key
     *                generated by {@link #pushPipelineUserKey(User)}
     */
    public void removePipelineUserKey(String key) {
        if (pipelineUserKeys == null) {
            log.error("pipelineUserKeys == null");
            return;
        }
        Object val = pipelineUserKeys.remove(key);
        if (val == null) {
            log.error("Unknown key in removePipelineUserKey: " + key);
        }
    }

    /**
     * Convert the given String representation back to is byte array.
     * 
     * @param arg
     * @return a byte array matching exactly
     * 
     * @author pcarr
     */
    public static byte[] convertToByteArray(String arg) {
	BigInteger bi = new BigInteger(arg, 16);
	return bi.toByteArray();
    }

    /**
     * Encode the given array of byte as a String to be passed as an argument on the java command line.
     * 
     * e.g. Given byte[] b; b equals convertToByteArray(convertToString(b));
     * 
     * @param byte_arr
     * @return a String which can be passed as a command line argument.
     * 
     * @author pcarr
     */
    public static String convertToString(final byte[] byte_arr) {
	BigInteger bigInteger = new BigInteger(byte_arr);
	return bigInteger.toString(16);
    }

    /**
     * Encrypts the clear text. The returned byte array is exactly 255 bytes, the size of the password field.
     * 
     * @param clearText, the unencrypted text, special-case null arg is converted to the empty String.
     * @return The encrypted text as a byte array
     * @throws NoSuchAlgorithmException
     */
    public static byte[] encrypt(final String clearText) throws NoSuchAlgorithmException {
	MessageDigest md = MessageDigest.getInstance("MD5");
	md.reset();
	try {
	    md.update(Strings.nullToEmpty(clearText).getBytes("UTF-8"));
	} catch (UnsupportedEncodingException e) {
	    log.error(e);
	}

	byte[] encryptedString = new byte[255];
	Arrays.fill(encryptedString, (byte) 0);
	byte[] digestedString = md.digest();
	for (int i = 0, length = Math.min(encryptedString.length, digestedString.length); i < length; i++) {
	    encryptedString[i] = digestedString[i];
	}
	return encryptedString;
    }

    public static EncryptionUtil getInstance() {
	return instance;
    }

    /**
     * Check if the given encrypted password was encrypted from the empty string (""). Note this method is not thread
     * safe because it uses lazy initialization for the EMPTY test case.
     * 
     * @param encryptedPassword
     * @return
     */
    public static boolean isEmpty(byte[] encryptedPassword) {
	if (EMPTY.length == 0) {
	    try {
		EMPTY = encrypt("");
	    } catch (NoSuchAlgorithmException e) {
		log.error(e.getLocalizedMessage(), e);
		return false;
	    }
	}
	return Arrays.equals(EMPTY, encryptedPassword);
    }

    public static void main(String[] args) throws Exception {
	String txt = "a";
	byte[] a1 = EncryptionUtil.encrypt(txt);
	byte[] a2 = EncryptionUtil.encrypt(txt);
	System.out.println(a1.length);
	System.out.println(java.util.Arrays.equals(a1, a2));
    }

}
